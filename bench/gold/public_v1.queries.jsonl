{"id": "k8s-eviction-001", "query": "where is the pod eviction logic when a node is under memory pressure", "repo": "kubernetes/kubernetes", "relevant": [{"path": "pkg/kubelet/eviction/eviction_manager.go"}, {"path": "pkg/kubelet/eviction/helpers.go"}], "task_type": "navigation", "notes": "Core eviction manager handles memory pressure signals"}
{"id": "k8s-scheduler-001", "query": "how does the scheduler pick which node to place a pod on", "repo": "kubernetes/kubernetes", "relevant": [{"path": "pkg/scheduler/scheduler.go"}, {"path": "pkg/scheduler/framework/runtime/framework.go"}], "task_type": "conceptual", "notes": "Scheduler uses framework plugins for node selection"}
{"id": "k8s-service-001", "query": "where are kubernetes service endpoints managed", "repo": "kubernetes/kubernetes", "relevant": [{"path": "pkg/controller/endpoint/endpoints_controller.go"}, {"path": "pkg/controller/endpointslice/endpointslice_controller.go"}], "task_type": "navigation", "notes": "EndpointSlice is the modern approach"}
{"id": "k8s-admission-001", "query": "how do admission webhooks validate pod creation", "repo": "kubernetes/kubernetes", "relevant": [{"path": "staging/src/k8s.io/apiserver/pkg/admission/plugin/webhook/validating/plugin.go"}, {"path": "staging/src/k8s.io/apiserver/pkg/admission/plugin/webhook/generic/webhook.go"}], "task_type": "conceptual", "notes": "Validating admission webhooks"}
{"id": "k8s-configmap-001", "query": "how are configmaps mounted into pods as volumes", "repo": "kubernetes/kubernetes", "relevant": [{"path": "pkg/volume/configmap/configmap.go"}, {"path": "pkg/kubelet/configmap/configmap_manager.go"}], "task_type": "conceptual", "notes": "ConfigMap volume plugin"}
{"id": "k8s-hpa-001", "query": "where is horizontal pod autoscaler scaling logic", "repo": "kubernetes/kubernetes", "relevant": [{"path": "pkg/controller/podautoscaler/horizontal.go"}, {"path": "pkg/controller/podautoscaler/replica_calculator.go"}], "task_type": "navigation", "notes": "HPA controller calculates desired replicas"}
{"id": "k8s-dns-001", "query": "how does kubernetes resolve service DNS names", "repo": "kubernetes/kubernetes", "relevant": [{"path": "pkg/kubelet/network/dns/dns.go"}, {"path": "pkg/apis/core/types.go"}], "task_type": "conceptual", "notes": "Kubelet configures pod DNS"}
{"id": "k8s-pv-001", "query": "where is persistent volume claim binding logic", "repo": "kubernetes/kubernetes", "relevant": [{"path": "pkg/controller/volume/persistentvolume/pv_controller.go"}, {"path": "pkg/controller/volume/persistentvolume/binder.go"}], "task_type": "navigation", "notes": "PV controller handles binding"}
{"id": "k8s-probe-001", "query": "how does kubelet execute liveness probes", "repo": "kubernetes/kubernetes", "relevant": [{"path": "pkg/kubelet/prober/prober.go"}, {"path": "pkg/kubelet/prober/prober_manager.go"}], "task_type": "conceptual", "notes": "Prober runs HTTP/exec/TCP probes"}
{"id": "k8s-rbac-001", "query": "where is RBAC authorization enforced", "repo": "kubernetes/kubernetes", "relevant": [{"path": "plugin/pkg/auth/authorizer/rbac/rbac.go"}, {"path": "staging/src/k8s.io/apiserver/pkg/authorization/authorizerfactory/builtin.go"}], "task_type": "navigation", "notes": "RBAC authorizer implementation"}
{"id": "vscode-ext-001", "query": "how does vscode load and activate extensions", "repo": "microsoft/vscode", "relevant": [{"path": "src/vs/workbench/services/extensions/browser/extensionService.ts"}, {"path": "src/vs/workbench/services/extensions/common/extensionHostManager.ts"}], "task_type": "conceptual", "notes": "Extension service manages lifecycle"}
{"id": "vscode-cmd-001", "query": "where is the command palette implemented", "repo": "microsoft/vscode", "relevant": [{"path": "src/vs/workbench/contrib/quickaccess/browser/commandsQuickAccess.ts"}, {"path": "src/vs/platform/quickinput/browser/quickInput.ts"}], "task_type": "navigation", "notes": "Quick access provides command palette"}
{"id": "vscode-editor-001", "query": "how does the text editor handle syntax highlighting", "repo": "microsoft/vscode", "relevant": [{"path": "src/vs/editor/common/languages/supports/tokenization.ts"}, {"path": "src/vs/editor/standalone/browser/standaloneLanguages.ts"}], "task_type": "conceptual", "notes": "Tokenization drives highlighting"}
{"id": "vscode-file-001", "query": "where is file watching implemented for the explorer", "repo": "microsoft/vscode", "relevant": [{"path": "src/vs/platform/files/node/watcher/watcherMain.ts"}, {"path": "src/vs/platform/files/node/watcher/parcel/parcelWatcher.ts"}], "task_type": "navigation", "notes": "Parcel watcher for file system events"}
{"id": "vscode-git-001", "query": "how does vscode integrate with git for source control", "repo": "microsoft/vscode", "relevant": [{"path": "extensions/git/src/git.ts"}, {"path": "extensions/git/src/repository.ts"}], "task_type": "conceptual", "notes": "Git extension wraps git CLI"}
{"id": "vscode-debug-001", "query": "where is the debug adapter protocol implemented", "repo": "microsoft/vscode", "relevant": [{"path": "src/vs/workbench/contrib/debug/browser/debugService.ts"}, {"path": "src/vs/workbench/contrib/debug/common/debugProtocol.ts"}], "task_type": "navigation", "notes": "Debug service implements DAP"}
{"id": "vscode-autocomplete-001", "query": "how does intellisense autocomplete work", "repo": "microsoft/vscode", "relevant": [{"path": "src/vs/editor/contrib/suggest/browser/suggestController.ts"}, {"path": "src/vs/editor/contrib/suggest/browser/suggestModel.ts"}], "task_type": "conceptual", "notes": "Suggest controller manages completions"}
{"id": "vscode-settings-001", "query": "where are user settings stored and loaded", "repo": "microsoft/vscode", "relevant": [{"path": "src/vs/platform/configuration/common/configurationService.ts"}, {"path": "src/vs/workbench/services/configuration/browser/configurationService.ts"}], "task_type": "navigation", "notes": "Configuration service handles settings"}
{"id": "vscode-terminal-001", "query": "how is the integrated terminal implemented", "repo": "microsoft/vscode", "relevant": [{"path": "src/vs/workbench/contrib/terminal/browser/terminalService.ts"}, {"path": "src/vs/workbench/contrib/terminal/browser/terminalInstance.ts"}], "task_type": "conceptual", "notes": "Terminal service manages xterm instances"}
{"id": "vscode-search-001", "query": "where is workspace text search implemented", "repo": "microsoft/vscode", "relevant": [{"path": "src/vs/workbench/services/search/node/ripgrepTextSearchEngine.ts"}, {"path": "src/vs/workbench/services/search/common/searchService.ts"}], "task_type": "navigation", "notes": "Ripgrep powers text search"}
{"id": "hf-tokenizer-001", "query": "how does the tokenizer encode text into tokens", "repo": "huggingface/transformers", "relevant": [{"path": "src/transformers/tokenization_utils_base.py"}, {"path": "src/transformers/tokenization_utils.py"}], "task_type": "conceptual", "notes": "Base tokenizer handles encoding"}
{"id": "hf-trainer-001", "query": "where is the training loop implemented", "repo": "huggingface/transformers", "relevant": [{"path": "src/transformers/trainer.py"}, {"path": "src/transformers/training_args.py"}], "task_type": "navigation", "notes": "Trainer class runs training"}
{"id": "hf-pipeline-001", "query": "how do inference pipelines work for text generation", "repo": "huggingface/transformers", "relevant": [{"path": "src/transformers/pipelines/text_generation.py"}, {"path": "src/transformers/pipelines/base.py"}], "task_type": "conceptual", "notes": "Pipeline provides easy inference API"}
{"id": "hf-attention-001", "query": "where is multi-head attention implemented", "repo": "huggingface/transformers", "relevant": [{"path": "src/transformers/models/bert/modeling_bert.py"}, {"path": "src/transformers/models/gpt2/modeling_gpt2.py"}], "task_type": "navigation", "notes": "Each model has attention implementation"}
{"id": "hf-config-001", "query": "how are model configurations loaded from hub", "repo": "huggingface/transformers", "relevant": [{"path": "src/transformers/configuration_utils.py"}, {"path": "src/transformers/utils/hub.py"}], "task_type": "conceptual", "notes": "PretrainedConfig handles loading"}
{"id": "hf-generate-001", "query": "where is beam search text generation implemented", "repo": "huggingface/transformers", "relevant": [{"path": "src/transformers/generation/utils.py"}, {"path": "src/transformers/generation/beam_search.py"}], "task_type": "navigation", "notes": "GenerationMixin has generate()"}
{"id": "hf-dataset-001", "query": "how does the data collator batch training examples", "repo": "huggingface/transformers", "relevant": [{"path": "src/transformers/data/data_collator.py"}, {"path": "src/transformers/trainer_utils.py"}], "task_type": "conceptual", "notes": "DataCollator pads and batches"}
{"id": "hf-quantize-001", "query": "where is model quantization to 8bit implemented", "repo": "huggingface/transformers", "relevant": [{"path": "src/transformers/integrations/bitsandbytes.py"}, {"path": "src/transformers/utils/quantization_config.py"}], "task_type": "navigation", "notes": "BitsAndBytes integration for quantization"}
{"id": "hf-save-001", "query": "how are pretrained models saved to disk", "repo": "huggingface/transformers", "relevant": [{"path": "src/transformers/modeling_utils.py"}, {"path": "src/transformers/configuration_utils.py"}], "task_type": "conceptual", "notes": "save_pretrained() in PreTrainedModel"}
{"id": "hf-peft-001", "query": "where is LoRA adapter loading implemented", "repo": "huggingface/transformers", "relevant": [{"path": "src/transformers/integrations/peft.py"}, {"path": "src/transformers/modeling_utils.py"}], "task_type": "navigation", "notes": "PEFT integration for adapters"}
